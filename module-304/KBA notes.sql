-- kba review
-- 1. a transaction can include one or more insert, update, or delete statements
-- 2. any changes made inside a transaction aren't visible to other database uers until you perform a commit 
-- word used to save a transaction is Commit
-- word used to get rid of teh transaction if error is Rollback

-- understand what is an ambiguous column in the database

-- we id update statemeents and you need to know the format for the update statement
-- update <tablename> set <columnname> = <value> where...;
select * from offices;
update offices set address_line2 = 'unknown' where id = 8;

-- we know our basic aggregate functions - min, max, avg, count, sum

-- why is normalization important? 
-- 1. reduce data redundancy
-- 2. improve data integrity (proper FK relationships, and proper naming of columns) (we store data w a like measurement, ex. miles, ft, in, but not both in the same column)
-- 3. we want to simplify maintenance


-- yes, you can use a subquery wile also using an aggregate function

-- if we want to show things that are not duplicates, use DISTINCT

-- you can use a combination of group by, having and where clauses in an sql statement, yes you can

-- , and why? you can, as long as it's in the correct order (see below)
-- anatomy of a select statement
-- select
-- from
-- where
-- group by
-- having
-- order by
-- limit

-- primary key
-- 1. is always unique by definition, doesn't need to be set to be unique, can be used to identify a single unique record in a table
-- 2. can't contain null values **
	select * from products where id is null; -- this will return 0 rows bc pk can't be null
-- 3. integer value
-- 4. auto incremented -- the value of the pk is automatically generated by using auto_increment
-- 5. primary key can have more than one column - true statement but is frowned upon and a bad practice
-- 6. used to access database records faster -- pk is the fastest way to look up the record in the database
-- 7. they help maintain referential integrity
-- 8. pk should be - numeric, not null, ai, and unique

-- need to know IS NULL vs = NULL
select * from offices where address_line2 = null; -- this will return 0 lines bc can't = null
select * from offices where address_line2 is null; -- this will work properly
select * from offices where address_line2 is not null; -- this will also work properly

-- thought processes
-- 1. identify the sub query and first try to think about what that subquery will return
-- 2. then pay attn to the where clause for a double negative or anything that negates the answer
-- 3. then you can consider the select or update part of the statement

-- what does the where clause do **
-- defines one or more conditions that must be met for data to be returned

-- why do we use constraints on the database (constraints are the data types, the not null or unique, etc)
-- 1. to limit the data that goes into the table for business requirements
-- 2. enhances data integrity 

-- what do we know about joins
-- 1. there is no known use for a cross join (speed dating)
-- 2. we know that a self join is when you are connecting to the id column in the same table
-- 3. we know that a non-equi-join is not even a real join
-- 4. we know that inner join can connect two or more tables together
-- 5. this is a true statement-- multiple types of joins can be used in the same query

-- default order by is acs (ascending)

-- when adding an FK relationship, which table to we add the FK relationshiup to
-- let's consider products and orderdetails, which table has the FK?
-- the table w the many side of the relationship, one orderdetails has many products
-- not the table w the id side
-- the alter table command w the add clause is needed to manually create a FK
-- In other words: foreign keys put the “relational” in “relational database” – they help define the relationships between tables.

-- limit keyword to limit the number of results in set

-- a fk is not required for a database - they're good practice but you can create a database w/out using an fk

